\subsection{Biblioteci de integrare}
\label{integration-libraries}

\subsubsection{Tipuri de evenimente pentru primitive de sincronizare}

Biblioteca pentru capturare de evenimente și programul de analiză
post-mortem sunt componente generice, refolosibile pentru orice fel de
analiză post-mortem de evenimente. Pentru a folosi aceste componente în
analiza primitivelor de sincronizare, trebuie mai întâi să definim
tipurile de evenimente ce descriu aceste primitive. Astfel, am creat
o interfață C ce conține constante numerice pentru tipurile de
evenimente specifice primitivelor de sincronizare, ce complimentează
constantele numerice oferite de interfața bibliotecii pentru capturarea
de evenimente.

Definim mai întâi câteva constante ce reprezintă
\textit{biți indicatori} din tipul evenimentului: tipul de obiect
țintă al evenimentului (\lstinline{SA_MUTEX} pentru \textit{mutex},
\lstinline{SA_REC_MUTEX} pentru \textit{mutex recursiv} și
\lstinline{SA_RWLOCK} pentru \textit{read-write lock}, similare cu
\lstinline{SA_EV_THREAD} pentru \textit{fire de execuție}, definită în
Secțiunea \textbf{\ref{section:library-interface}}) și acțiunea ce are
loc pe acel obiect țintă (\lstinline{SA_BEFORE_WR_LOCK},
\lstinline{SA_AFTER_WR_LOCK} și altele, din nou similare cu constantele
\lstinline{SA_EV_CREATE} și \lstinline{SA_EV_DESTROY} din Secțiunea
\textbf{\ref{section:library-interface}}). Lista completă a tipurilor de
evenimente capturate, împreună cu valorile acestora obținute din biții
indicatori este următoarea:

\begin{lstlisting}[caption=Tipurile de evenimente pentru primitivele de
                           sincronizare, label=code:syan-event-types]
SA_EV_THREAD_ON_JOIN        = SA_EV_THREAD | SA_JOIN,
SA_EV_THREAD_ON_DETACH      = SA_EV_THREAD | SA_DETACH,
SA_EV_MUTEX_ON_CREATE       = SA_MUTEX     | SA_EV_CREATE,
SA_EV_MUTEX_ON_TRY_LOCK     = SA_MUTEX     | SA_TRY_WR_LOCK,
SA_EV_MUTEX_BEFORE_LOCK     = SA_MUTEX     | SA_BEFORE_WR_LOCK,
SA_EV_MUTEX_AFTER_LOCK      = SA_MUTEX     | SA_AFTER_WR_LOCK,
SA_EV_MUTEX_ON_UNLOCK       = SA_MUTEX     | SA_WR_UNLOCK,
SA_EV_MUTEX_ON_DESTROY      = SA_MUTEX     | SA_EV_DESTROY,
SA_EV_REC_MUTEX_ON_CREATE   = SA_REC_MUTEX | SA_EV_CREATE,
SA_EV_REC_MUTEX_ON_TRY_LOCK = SA_REC_MUTEX | SA_TRY_WR_LOCK,
SA_EV_REC_MUTEX_BEFORE_LOCK = SA_REC_MUTEX | SA_BEFORE_WR_LOCK,
SA_EV_REC_MUTEX_AFTER_LOCK  = SA_REC_MUTEX | SA_AFTER_WR_LOCK,
SA_EV_REC_MUTEX_ON_UNLOCK   = SA_REC_MUTEX | SA_WR_UNLOCK,
SA_EV_REC_MUTEX_ON_DESTROY  = SA_REC_MUTEX | SA_EV_DESTROY,
SA_EV_RWLOCK_ON_CREATE      = SA_RWLOCK    | SA_EV_CREATE,
SA_EV_RWLOCK_ON_TRY_RD_LOCK = SA_RWLOCK    | SA_TRY_RD_LOCK,
SA_EV_RWLOCK_BEFORE_RD_LOCK = SA_RWLOCK    | SA_BEFORE_RD_LOCK,
SA_EV_RWLOCK_AFTER_RD_LOCK  = SA_RWLOCK    | SA_AFTER_RD_LOCK,
SA_EV_RWLOCK_ON_RD_UNLOCK   = SA_RWLOCK    | SA_RD_UNLOCK,
SA_EV_RWLOCK_ON_TRY_WR_LOCK = SA_RWLOCK    | SA_TRY_WR_LOCK,
SA_EV_RWLOCK_BEFORE_WR_LOCK = SA_RWLOCK    | SA_BEFORE_WR_LOCK,
SA_EV_RWLOCK_AFTER_WR_LOCK  = SA_RWLOCK    | SA_AFTER_WR_LOCK,
SA_EV_RWLOCK_ON_WR_UNLOCK   = SA_RWLOCK    | SA_WR_UNLOCK,
SA_EV_RWLOCK_ON_DESTROY     = SA_RWLOCK    | SA_EV_DESTROY,
\end{lstlisting}

\subsubsection{cxxsync (C++, începând cu C++11)}
\lstinline{cxxsync} este o bibliotecă de C++ proiectată pentru a fi un
exemplu de integrare cu biblioteca de capturare de evenimente. Nu este
neapărat cea mai bună soluție pentru integrarea în proiecte existente,
deoarece are o interfață diferită de alte biblioteci existente, deci
sunt necesare schimbări în codul sursă pentru integrare. Această
bibliotecă este folosită de exemplu în testele analizorilor descriși în
secțiunea \textbf{\ref{analyzers}}.

Biblioteca expune 4 clase principale, pentru cele 4 primitive ale căror
evenimente ne interesează: \lstinline{Mutex} pentru \textit{mutex},
\lstinline{RecursiveMutex} pentru \textit{mutex recursiv},
\lstinline{RWLock} pentru \textit{read-write lock} și \lstinline{Thread}
pentru \textit{fir de execuție}. Primele 3 dintre acestea au și
câteva clase auxiliare atașate pentru a implementa tehnica
\textit{RAII}\cite{RAII}, foarte populară și utilă în programele moderne
C++ (clasele \lstinline{MutexGuard},
\lstinline{RecursiveMutexGuard}, \lstinline{RWLockReadGuard} și
\lstinline{RWLockWriteGuard}). În implementarea tuturor claselor se
folosesc funcții din biblioteca \lstinline{pthread} și se capturează
evenimente folosind funcția \lstinline{syan_capture_event}, descrisă în
Secțiunea \textbf{\ref{section:library-interface}}, și tipuri de
evenimente dintre cele descrise în Fragmentul de cod
\ref{code:syan-event-types}.

Clasa \lstinline{Thread} crează un fir de execuție printr-un apel al
funcției \lstinline{pthread_create} în constructor. Pentru a admite
sintaxa elegantă de funcții \textit{lambda} din C++11 pentru
inițializarea firului de execuție, s-a folosit tehnica C++ cunoscută ca
\textit{type erasure}\cite{TypeErasure}, mai exact transformarea unui
tip de date necunoscut, primit ca \textit{parametru de template},
într-unul cunoscut, în acest caz \lstinline{void*(*)(void*)}
(\textit{pointer} la o funcție ce primește ca parametru un
\lstinline{void*} și returnează un \lstinline{void*}; acesta este tipul
de date pe care îl primește funcția \lstinline{pthread_create} ca
parametru pentru a inițializa noul fir de execuție). Implementarea
constructorului clasei \lstinline{Thread} folosind această tehnică,
și de asemenea folosirea funcțiilor \lstinline{syan_initialize_event} și
\lstinline{syan_finalize_event} în locul funcției
\lstinline{syan_capture_event} din motivele precizate în secțiunea
\textbf{\ref{section:library-interface}} se pot vedea în Fragmentul de
cod \ref{code:thread-type-erasure}.
\begin{lstlisting}[caption=Tehnica \textit{type-erasure} în
                           implementarea clasei \lstinline{Thread} din
                           \lstinline{cxxsync},
                   float, floatplacement=H,
                   label=code:thread-type-erasure]
    template<class Func> // constructorul clasei Thread
    Thread::Thread(Func callable) {
        init_thread(&erased_func<Func>, new Func(callable));
    }

    template<class Func>
    void* erased_func(void* arg) {
        Func* func = static_cast<Func*>(arg);
        (*func)();
        delete func;
        return nullptr;
    }

    void Thread::init_thread(void* (*func)(void*), void* arg) {
      void* ev = syan_initialize_event(SA_EV_THREAD_ON_CREATE);
      pthread_create(&pt_thread, nullptr, func, arg);
      syan_finalize_event(ev, (void*)pt_thread);
    }
\end{lstlisting}
Interfața claselor \lstinline{Mutex} și \lstinline{MutexGuard} este
descrisă în Fragmentul de cod \ref{code:cxxsync-mutex}, clasele pentru
\textit{mutex recursiv} și \textit{read-write lock} având interfețe
similare.
\begin{lstlisting}[caption=Interfața claselor \lstinline{Mutex} și
                           \lstinline{MutexGuard} din biblioteca
                           \lstinline{cxxsync},
                   float, floatplacement=H, label=code:cxxsync-mutex]
#include <pthread.h>
namespace sync {
struct Mutex {
    Mutex();
    ~Mutex();
    bool try_lock() noexcept;
    void lock();
    void unlock();
private:
    pthread_mutex_t pt_mutex;
};
struct MutexGuard {
    explicit MutexGuard(Mutex* mtx): mtx(mtx) { mtx->lock(); }
    ~MutexGuard() { mtx->unlock(); }
private:
    Mutex* mtx;
};
}  // namespace sync
\end{lstlisting}

\subsubsection{pthread shim (C/C++)}

\subsubsection{libc++ shim (pentru C++, începând cu C++11)}
